> 很早之前就知道Java的代理，同时也在设计模式这本书中了解了代理模式。于是开始尝试基于Java原生特性进行动态代理。
> 代理的很大的一个好处就是解耦合，通过这种手段，可以使程序有很好的可读性，而且在模块化上有着更好的实现，其实在Spring框架中，他所使用的AOP，很大程度上也是基于动态代理的方式进行的。
> 对于我们自己编写的代理类，我们可以随意的进行字节码的操操作，方便我们进行字节码的增强。有关字节码的增强，我会在下一篇日志中进行详细的描述。

> 现在先说一个使用ClassLoader的代理模式的简单例子。

> #### 我们现在有一个接口。接口中的代码如下:
> > ![image](images/2013-12-10-1.png)

> #### 这边是我的实现类代码，如下:
> > ![image](images/2013-12-10-2.png)

> #### 这是我的主函数，同时也是执行代理的主要内容:
> > ![image](images/2013-12-10-3.png)

> 在这边主要需要详细说一下这个ProxyMain类，我们可以看到这边这个类实现了InvocationHandler接口，这主要是用来实现对代理的全部Something类的方法的调用。
> 这个Proxy主要使用了Java反射API，将一般的方法调用映射到SomethingImp接口中，由此类推。

> 但这样的简单的例子，也有许多简单的代码。使用这些字节操作类库也是同样的具有挑战性。代码量和复杂度是代理的两大特点。创建简单的代码十分的困难。但是这样的代理也没有提供在系统范围内指定执行点的功能。但是这一点正好是AOP解决办法的关键点。
> 面向切面编程正式希望有这么一种机制，将业务逻辑横向切分。从而达到代码复用等一系列的优点。

> 写这篇文章的目的，就是因为有些同学问我面向切面编程的好处，同时，如何进行字节码操作(关于这一点，我将在之后的日志中详细描述)，在代码量比较小的项目中，面向切面的优势确实无法提现，不过面向接口编程的思想，确实得需要自己的领悟。
> 通过这样的代码编写，再不考虑性能的情况下，可以热替代代码，比如一些工具类，我们可以在调用时采用这样的方法进行编写。这样的好处就是，如果需要热替代代码，只需要将对应的class文件进行替换，即可。
