JMS保证消息传达模型
---
在所谓的JMS系统开发中,我们常常会有一个需求，就是消息发送端需要了解客户端是否已经收到消息，来确保接下来的业务逻辑不会出现大的错误，
假设我们没有使用JMS协议，而是我们自己进行编写消息传递的消息协议，用来确保消息的传递。举一个最简单的例子，我们就可以模仿TCP/IP的
三次握手协议，在每次进行消息传递的时候进行握手操作，并且在之后进行一个放手协议。这样，我们的消息发送方就可以了解到目前业务的进展
情况，并且进入下一步的操作当中。

但是，这样还是会带来一个问题，就是当消息发送之后，客户端接受了，然后进行处理，此时， 网络断了，死机了，怎么办?简单的办法，做一个
超时检测，如果在一定时间没有回复，则认为发送失败。于是进行重发。可行。但是又有一个新的问题，如果一个消息有大概三个操作，客户端在
完成一个操作之后，断开连接，然后新的消息传递到，又需要进行第一步操作，发现是已经完成的，然后常见的程序写法会认为任务已经做完，然后
返回，但实际上这个任务是没有完成的。所以为了避免这种情况，我们可以对消息的运行状况进行一个约定，比如完成第一步，就返回`MessageID+StepID`。
完美，这样消息就能高效的进行处理了。

但是，转念一想，这不就是把业务逻辑绑定到了消息传递中了吗，我们为什么要引入消息传递，很大程度上就是进行解藕，但是看看这个所谓的消息机制
完全的就是之前程序的分布式版本，没有一点解藕的迹象。所以这个方法必定是失败的。因为他没有将消息传递的结构性功能发挥出来。

所以这边我们可以看看JMS是提供了一个怎样的思路。

看上去，这是一个比较良好的解决方案，但是，还有一个问题没有考虑到，就是我们为什么需要JMS，或者是消息模型。就是需要有一个消息中心进行消息
的转发，从而可以更加方便的使用这个消息服务器进行负载均衡或者是进行横向拓展，这也是为什么SUN的Java先驱们提出JMS模型的一个初始动力。所以
他山之石可以工玉，我们可以参照JMS的模型来完善我们自己的消息模型。为什么不使用已经工业化的消息中间件呢，其实原因也很简单，通用的始终比不上
专用的，应用场景不同，最佳的设计也就不同，你很难在市面上免费的得到一个适合你业务场景的消息中间件，就像淘宝也自己编写了[Notify]()和[MetaQ](http://metaq.taobao.org/),
原因就是适应业务的特殊场景。

