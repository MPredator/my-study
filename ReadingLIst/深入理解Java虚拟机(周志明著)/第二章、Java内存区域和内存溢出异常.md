第二章、Java内存区域和内存溢出异常
---

>1. 现在了解到JVM在运行时会有五块内存区域：方法区，虚拟机栈，本地方法栈，堆区还有程序运行器。

>2. 在五个区域中，只有堆区和方法区是线程之间可以共享的，其余的几个内存区域是线程隔离的，也就是说，每个线程都会有这么几个内存区域(我之前看的一本书把这几个区域统称为线程的缓存)，这就会有一个脏数据问题，因为线程内读到的数据是在线程栈中的，并不是最新的，所以就有了volatile关键字，他做到的是让虚拟机用到这个变量时都会重新读取这个变量的值，而不是使用保存在线程内部内存里的备份。

>3. 程序计数器使用来记录字节码运行行数，类似一个断点记录的功能，标志着程序的运行情况。这个区域也是JVM标准中唯一一个不可能出现OutOfMemoryError的地方。

>4. Java虚拟机栈和本地方法栈其实是面向不同对象的统一功能，Java虚拟机栈就是用来保存Java的方法调用信息的，本地方法栈用于保存Native方法，所以在HotSpot虚拟机中(也是我们最常用的Java虚拟机)中，这两块内存区是并为一块。

>5. Java堆空间和C++、C的堆空间意义相同。几乎所有的对象都会在这边实例化同时进行分配内存。不过这边它承担了GC的功能，也就是垃圾回收，这边就会涉及到垃圾回收算法，这一章是该书的下一章，下次日报写。

>6. Java方法区，用来存储虚拟机加载的类信息和常量，静态变量还有JIT编译后的代码。这个空间内可以选择性的使用垃圾回收，举个例子，常量池会出现在这个内存区域中。
	* 常量池是我们编译的class文件中，除了版本，字段，方法，接口之外的信息，我们比较常用到常量池的地方就是在使用String.intern()，这个函数。

>7. 直接内存，这就是Java引入NIO之后出现的新的内存区域，使用Native库进行直接的内存分配，举个例子，如果Native使用C编写，则可能会使用Molloc函数。

>8. 总体上，按我的理解，可以用个例子可以将Java的内存机制表述出来。
	* 我们编写Object obj = new Object();
	* 运行的时候，Object obj会反映到本地变量表里，作为一个reference(引用)出现。
	* 而后的new则会在Java堆中，申请空间，形成一段储存实际值的内存。
	* 而方法区则会储存对象类型，父类，实现的接口等信息。而这些信息的地址信息则会储存在Java堆区。
	* 如果使用reference进行访问该数据，则JVM会在本地的常量池中进行查找是否有该reference,这其中就是通过指针进行传递，只不过Java进行了封装。
